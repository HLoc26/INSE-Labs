# Task 1: Public-key based authentication 
**Question 1**: 
Implement public-key based authentication step-by-step with openssl according the following scheme.
![alt text](image-1.png)

**Answer 1**:

## Step 1: Preparing the environment
### 1.1. Create docker VMs
I have created 2 docker container named lab2-server for the server machine and lab2-client for the client machine:

![image](https://github.com/user-attachments/assets/9f87fce3-d9a6-415b-9867-7c038bdab777)

### 1.2. Install nessesary packages
Then, on both machine, install the nessesary packages:

1. `openssl`: To use openssl
2. `netcat` (traditional): To send and receive files, specifically the public key.
3. `net-tools`: To use the command `ifconfig` to see the IP address of the machine.

Command: `apt update && apt install openssl netcat-traditional net-tools`

## Step 2: Create client's private and public keys
### 2.1. Create private key

I used RSA to encrypt the private key, with the length of 512 bits for faster computational speed (since this is just a lab, the length should be 2048 bits or more in real life)

Command: `openssl genrsa -out client_private.pem 512`

Explain the command:

- `genrsa`: Generate RSA private key.
- `client_private.pem`: The file name to save the private key in.
- `512`: The length of the private key.

The private key is saved in file named `client_private.pem`

![image](https://github.com/user-attachments/assets/80b499fa-061e-44bf-86b2-eea52b2ac933)

### 2.2. Create public key

From the private key, we can generate the public key using the following command:

```
openssl rsa -in client_private.pem -pubout -out client_public.pem
```

The above command uses the `client_private.pem` as input, and extract a public key from the private key (`-pubout`) and save the public key to `client_public.pem` (`-out client_public.pem`)

![image](https://github.com/user-attachments/assets/4ad5c396-cf85-4dd4-9562-2846fec0beac)

### 2.3. Send public key to server machine

In order to send the public key `client_public.pem` to the server machine, we use `netcat`.

First, on the server, we have to know the IP address of the machine:

![image](https://github.com/user-attachments/assets/584567f5-0974-41fd-b41e-75f776745a0a)

The IP address of the server is `172.17.0.2`

First, the server have to be listening on a port (I used port 4444) using the command 

```
nc -lv -p 4444 > client_public.pem
```

![image](https://github.com/user-attachments/assets/27c189de-fc06-4dc1-985f-60094e773707)

The server machine will be listening (`-l`) on port 4444 (`-p 4444`), and will print out the log (`-v`). The receive bits will be saved into `client_public.pem` on the server machine.

Then, the client can send the file using
```
nc 172.17.0.2 4444 < client_public.pem
```
The client machine will send the file `client_public.pem` to the server's IP address, port 4444

![image](https://github.com/user-attachments/assets/8f87de58-3585-425b-ae42-702cfa5fbfc2)

Now, the client_public is now on the server machine

![image](https://github.com/user-attachments/assets/6ea07a03-637a-4918-b1a3-ab5cbc2e39e8)

We can see that the public key is the same on both machine. The public key is sent successfully.

## Step 3: Encrypt the message

First, create a `challenge.txt` file
```
echo "Hello from the server" > challenge.txt
```

And encrypt the message using the following command
```
openssl pkeyutl -encrypt -inkey client_public.pem -pubin -in challenge.txt -out challenge.enc
```

The command will encrypt the file `challenge.txt` using the public key from `client_public.pem`. The result will be saved in `challenge.enc`/

![image](https://github.com/user-attachments/assets/7932eda8-1703-40b5-a621-f398c09dd764)

## Step 4: Send the encrypted message to the client.

Note that on [step 2.3](#2.3.-Send-public-key-to-server-machine),

# Task 2: Encrypting large message 
Create a text file at least 56 bytes.
**Question 1**:
Encrypt the file with aes-256 cipher in CFB and OFB modes. How do you evaluate both cipher as far as error propagation and adjacent plaintext blocks are concerned. 
**Answer 1**:

**Question 2**:
Modify the 8th byte of encrypted file in both modes (this emulates corrupted ciphertext).
Decrypt corrupted file, watch the result and give your comment on Chaining dependencies and Error propagation criteria.

**Answer 2**:





